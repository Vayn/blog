---
layout: post
title: '{Diary} "Hackers and Painters" Note 4'
author: Vayn
date: 2011-04-28
categories:
  - note
  - thought
---

<a title="黑客与画家" href="http://book.douban.com/subject/6021440/"><img alt="黑客与画家" src="http://img3.douban.com/mpic/s4669554.jpg"></a>

## 12 拒绝平庸

### P176-177

> 只要这位程序员向曲线下方望去，他就肯定知道自己正在看的是一些比较低层次的语言。因为那些语言明显不如 Blub （作者假想的一种语言）强大，缺少他习惯使用的某些功能。但是，当他向曲线上方望去，他不会意识到自己正在看更高层次的语言，而是仅仅觉得自己正在看某些奇怪的语言。他可能认为那些语言也许与 Blub 一样强大，但是加入了不少怪东西。他觉得 Blub 语言已经够用了，不用再考虑那些语言了。这时，他的思维就是已经被 Blub 同化了。

> 通过归纳法我们就会知道，唯一洞悉所有语言优劣的人必然是懂得最强大的那种语言的人。（这大概是埃里克.雷蒙德所说的 Lisp 语言使你成为一个更好的程序员的意思。）

希望我还没有被哪一种语言同化。

> 与其说 Lisp 有一种很奇特的语法，还不如说它根本没有语法。一般的源代码程序经过编译器解析会生成*解析树*。Lisp 的奇特之处就在于，你可以完全写出程序，控制这种解析树，进行任意的存取操作。Lisp 的这种程序就叫做宏，它们可以用来生成其他程序。

解析器（parser）：读取输入的数据然后生成解析树的程序。

解析树（parse tree）：解析器读取源码后生成的数据结构。它是将源码翻译成机器语言的第一步。

## 13 书呆子的复仇

### P184-185

> 简单说，因为这种语言（指 Lisp）本质上不是一种技术，而是数学。数学是不会过时的。你不应该把 Lisp 语言与 50 年代的硬件联系在一起，而是应该把它与快速排序（Quicksort）算法进行类比。

### P186-187

> 说 Lisp 语言古怪倒不是因为它的语法很古怪，而是因为它根本没有语法，程序直接以解析树的形式表达出来。在其他语言中，这种形式只是经过解析在后台产生，但是 Lisp 直接采用它作为表达形式。它由列表构成，而列表则是 Lisp 的基本数据结构。

### P188-189

> 那么到底应该怎么选择语言？是根据函数库，还是根据语言本身的能力？很难确切地找出一条清楚的规则，但是无论哪种情况，你都必须考虑到你开发的应用程序的特点。

### P190-191

> 事实上，选择更强大的编程语言会减少所需要的开发人员数量。因为：a）如果你使用的语言很强大，可能会减少一些编程的工作量，也就不需要那么多黑客了；b）使用更高级语言的黑客可能比别的程序员更聪明。

> 强大的编程语言如何让你写出更短的程序？一个技巧就是（在语言允许的前提下）使用“自下而上”（bottom-up）的编程方法。
>
> 代码数量很重要，因为开发一个程序所耗费的时间主要取决于程序的长度。对于同一个软件，如果用一种语言写出来的代码比用另一种语言长三倍，这意味着你开发它耗费的时间也会多三倍。

## 14 梦寐以求的编程语言

### P202-203

> 黑客改造语言的乐趣就好比外科医生摆弄病人内脏的乐趣（Vayn：Errr...）， 或者青少年喜欢用手挤破青春痘的那种感觉。

> 一种真正优秀的编程语言应该既整洁又混乱。“整洁”的意思是设计得很清楚，内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。“混乱”的意思是它允许黑客以自己的方式使用。

### P206-207

> 编程时提高代码运行速度的关键是使用好的性能分析器（profiler），而不是使用其他方法，比如精心选择一种静态类型的编程语言。

> 一个好的性能分析器对程序的帮助可能大于编译器的作用。

> 让性能分析器自动运行可能是一个好主意。

### P208-209

*帕金森（Parkison's Law）定律*

> 大多数人接触新事物时都学会了使用类似的过滤机制。……这样做完全是合理的，因为大多数的热门商品事后被证明都是浪费时间的噱头，没多久就消失得无影无踪。

很多语言也是如此。

> 所以，发明新事物的人必须有耐心，要常年累月不断地做市场推广，直到人们开始接受这种发明。

> 大多数技术在诞生后都逐渐发年了巨大的变化，编程语言更是如此。……早期使用者都是行家，要求也很高，能够很快找出你的技术中存在的缺点。而且如果你的用户只有很少的几个人，你就能够与他们所有人保持密切接触。只要不断改进你的系统，即使给用户造成了损失，早期使用者也会对你宽容大度的。

### P210-211

> 著名散文家 E.B.怀特说过， __“最好的文字来自不停的修改。”__ 所有优秀作家都知道这一点，它对软件开发也适用。设计一样东西，最重要的一点就是要经常“再设计”，编程尤其如此，再多的修改都不过分。

> 为了写出优秀软件，你必须同时具备这两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。

> 你必须对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。

## 15 设计与研究

### P214-215

> 让用户满意并不等于迎合用户的一切要求。用户不了解所有可能的选择，也经常弄错自己真正想要的东西。

> 这里的重点是你必须选出某些人作为你的目标用户。我觉得，除非设定目标用户，否则一种设计的好坏根本无从谈起。

> 如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。
>
> 低估用户（即使出于善意）一般来总是会让设计师出错。我怀疑那些设计“公共住宅项目”的建筑师根本没想过自己住在里面会是什么感觉。编程语言也有这种现象。C、Lisp 和 Smalltalk 都是设计者为了自己使用而设计的，而 Cobol、Ada 和 Java 则是为了给别人使用而设计的。

> 如果你觉得自己在为傻瓜设计产品，那么很可能不仅无法设计出优秀产品，而且就连傻瓜也不喜欢你的设计。

> 怎么理解编程语言？你不要把它看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。

### P216-217

> 在软件领域，贴近用户的设计思想被归纳为“弱即是强”（Worse is better）模式。……其中有一点是正确的，那就是如果你正在设计某种新东西，就应该尽快拿出原型，听取用户的意见。

> 几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。
>
> 软件开发也可以这样做。原型（prototype）并不只是模型（model），不等于将来一定要另起炉灶，你完全能够在原型的基础上直接做出最后的成品。……这样的方式使得你可以利用在开发过程中一路产生的新想法。不过更重要的是，这样做有助于鼓舞士气。

### P218-219

> 士气是设计的关键因素。……我的一位美术起蒙老师告诉我：如果你觉得画某样东西很乏味，那么你画出来的东西就会真的很乏味。

> 开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。

> “画作永远没有完工的一天，你只是不再画下去而已。”

> 士气也可以解释为什么很难为低端用户设计出优秀产品。因为优秀设计的前提是你自己必须喜欢这种产品，否则你不可能对设计有兴趣，更不要说士气高昂了。

> 设计意味着做出符合人类特点和需要的产品。但是，“人类”不仅包括用户，还包括设计师自己。

_Access to computers--and anything that might teach you something about the way the world works--shoud be unlimited and total. Always yield to the Hands-On Imperative!_

EOF
